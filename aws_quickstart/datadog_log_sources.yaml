AWSTemplateFormatVersion: 2010-09-09
Description: AWS Log Sources Sync
Parameters:
  DatadogApiKey:
    Description: >-
      API key for the Datadog account
    Type: String
    NoEcho: true
    Default: ""
  DatadogAppKey:
    Description: >-
      APP key for the Datadog account
    Type: String
    NoEcho: true
    Default: ""
  DatadogSite:
    Type: String
    Default: datadoghq.com
    Description: Define your Datadog Site to send data to.
    AllowedValues:
      - datadoghq.com
      - datadoghq.eu
      - us3.datadoghq.com
      - us5.datadoghq.com
      - ddog-gov.com
  LogSources:
    Type: CommaDelimitedList
    Description: >-
      A comma separated list of AWS Log Sources to forward to Datadog. 
      (Only used if InstallLambdaLogForwarder set to "true")
    Default: "s3,elb,elbv2,cloudfront,redshift,lambda,apigw-access-logs,apigw-execution-logs"
  ForwarderArn:
    Type: String
    Description: >-
      The ARN of the forwarder created for sending logs to Datadog
    Default: ""
  LambdaExecutionRole:
    Description: >-
      The role used by lambdas created for calling the Datadog API.
    Type: String
Resources:
  DatadogAPISyncLogSourcesCall:
    Type: "Custom::DatadogAPISyncLogSourcesCall"
    Properties:
      ServiceToken: !GetAtt DatadogLogSourcesSyncFunction.Arn
      APIKey: !Ref DatadogApiKey
      APPKey: !Ref DatadogAppKey
      ApiURL: !Ref DatadogSite
      AccountId: !Ref AWS::AccountId
      ForwarderArn: !Ref ForwarderArn
      LogSources: !Ref LogSources
  DatadogLogSourcesSyncFunction:
    Type: "AWS::Lambda::Function"
    Properties:
      Description: "A function to call the Datadog API for syncing log sources."
      Role: !Ref LambdaExecutionRole
      Handler: "index.handler"
      Runtime: "python3.8"
      Timeout: 30
      Code:
        ZipFile: |
          import boto3
          import json
          import logging
          import signal
          from urllib.request import build_opener, HTTPHandler, Request
          import urllib.parse
          LOGGER = logging.getLogger()
          LOGGER.setLevel(logging.INFO)

          log_source_names = {
              "API Gateway Access": "apigw-access-logs",
              "API Gateway Execution": "apigw-execution-logs",
              "Application ELB Access": "elbv2",
              "Classic ELB Access": "elb",
              "Cloudfront Access": "cloudfront",
              "Lambda Cloudwatch": "lambda",
              "Redshift": "redshift",
              "S3 Access": "s3",
          }

          def call_datadog_api(event, method):
              api_key = event['ResourceProperties']['APIKey']
              app_key = event['ResourceProperties']['APPKey']
              api_url = event['ResourceProperties']['ApiURL']
              account_id = event['ResourceProperties']['AccountId']
              forwarder_arn = event['ResourceProperties']['ForwarderArn']
              log_sources = event['ResourceProperties']['LogSources']

              # Make the url Request for the create call
              url = 'https://api.' + api_url + '/api/v1/integration/aws/logs'
              values = {
                  'account_id': account_id,
                  'lambda_arn': forwarder_arn
              }
              headers = {
                  'DD-API-KEY': api_key,
                  'DD-APPLICATION-KEY': app_key,
              }
              data = json.dumps(values)
              data = data.encode('utf-8')  # data should be bytes
              request = Request(url, data=data, headers=headers)
              request.add_header('Content-Type', 'application/json; charset=utf-8')
              request.add_header('Content-Length', len(data))
              request.get_method = lambda: method

              # Send the url Request, store external_id
              response = urllib.request.urlopen(request)
              if response.getcode() != 200 or method != "POST":
                  return response

              # Make the request to set the log services for the account
              url = 'https://api.' + api_url + '/api/v1/integration/aws/logs/services'
              values = {
                  'account_id': account_id,
                  'services': [log_source_names[source.strip()] for source in log_sources]
              }
              data = json.dumps(values)
              data = data.encode('utf-8')  # data should be bytes
              request = Request(url, data=data, headers=headers)
              request.add_header('Content-Type', 'application/json; charset=utf-8')
              request.add_header('Content-Length', len(data))
              request.get_method = lambda: method
              response = urllib.request.urlopen(request)

              return response

          def handler(event, context):
              '''Handle Lambda event from AWS'''
              try:
                  LOGGER.info('REQUEST RECEIVED:\n %s', event)
                  LOGGER.info('REQUEST RECEIVED:\n %s', context)
                  if event['RequestType'] == 'Create':
                      LOGGER.info('Received Create request.')
                      response = call_datadog_api(event, 'POST')
                      if response.getcode() == 200:
                          send_response(event, context, "SUCCESS",
                                        {
                                            "Message": "Datadog AWS Log Config created successfully.",
                                        })
                      else:
                          LOGGER.info('Failed - exception thrown during processing.')
                          send_response(event, context, "FAILED", {
                              "Message": "Http response: {}".format(response.msg)})

                  elif event['RequestType'] == 'Update':
                      LOGGER.info('Received Update request.')
                      send_response(event, context, "SUCCESS",
                                    {"Message": "Update not supported, no operation performed."})
                  elif event['RequestType'] == 'Delete':
                      LOGGER.info('Received Delete request.')
                      response = call_datadog_api(event, 'DELETE')

                      if response.getcode() == 200:
                          send_response(event, context, "SUCCESS",
                                        {
                                            "Message": "Datadog AWS Log Config deleted successfully.",
                                        })
                      else:
                          LOGGER.info('Failed - exception thrown during processing.')
                          send_response(event, context, "FAILED", {
                              "Message": "Http response: {}".format(response.msg)})

                  else:
                      LOGGER.info('Failed - received unexpected request.')
                      send_response(event, context, "FAILED",
                                    {"Message": "Unexpected event received from CloudFormation"})
              except Exception as e:  # pylint: disable=W0702
                  LOGGER.info('Failed - exception thrown during processing.')
                  send_response(event, context, "FAILED", {
                      "Message": "Exception during processing: {}".format(e)})


          def send_response(event, context, response_status, response_data):
              '''Send a resource manipulation status response to CloudFormation'''
              response_body = json.dumps({
                  "Status": response_status,
                  "Reason": "See the details in CloudWatch Log Stream: " + context.log_stream_name,
                  "PhysicalResourceId": context.log_stream_name,
                  "StackId": event['StackId'],
                  "RequestId": event['RequestId'],
                  "LogicalResourceId": event['LogicalResourceId'],
                  "Data": response_data
              })
              formatted_response = response_body.encode("utf-8")

              LOGGER.info('ResponseURL: %s', event['ResponseURL'])
              LOGGER.info('ResponseBody: %s', response_body)

              opener = build_opener(HTTPHandler)
              request = Request(event['ResponseURL'], data=formatted_response)
              request.add_header('Content-Type', 'application/json; charset=utf-8')
              request.add_header('Content-Length', len(formatted_response))
              request.get_method = lambda: 'PUT'
              response = opener.open(request)
              LOGGER.info("Status code: %s", response.getcode())
              LOGGER.info("Status message: %s", response.msg)

          def timeout_handler(_signal, _frame):
              '''Handle SIGALRM'''
              raise Exception('Time exceeded')

          signal.signal(signal.SIGALRM, timeout_handler)
