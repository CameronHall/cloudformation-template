AWSTemplateFormatVersion: 2010-09-09
Description: Resource Type Configuration
Parameters:
  ApiKey:
    Description: >-
      Your Datadog API Key
    Type: String
    NoEcho: true
    Default: ""
  AppKey:
    Description: >-
      Your Datadog APP Key
    Type: String
    NoEcho: true
    Default: ""
  ApiUrl:
    Type: String
    Default: datadoghq.com
    Description: Define your Datadog Site to send data to.
    AllowedValues:
      - datadoghq.com
      - datadoghq.eu
      - us3.datadoghq.com
      - us5.datadoghq.com
      - ddog-gov.com
  IAMRoleName:
    Description: >-
      The name of the IAM Role used for the Datadog AWS Integration
    Type: String
    Default: DatadogIntegrationRole
  HostTags:
    Type: CommaDelimitedList
    Default: ""
    Description: >-
      A comma seperated list of tags to add to hosts and metrics
  ObservabilityPermissions:
    Description: >-
      Customize the observability permissions for the Datadog IAM role.
      Select "Limited Permissions" to only grant Datadog permissions to monitor a limited set of metrics and metadata
      (not recommended).
    Type: String
    Default: Standard Permissions
    AllowedValues:
      - Standard Permissions
      - Limited Permissions
  CloudTrails:
    Description: >-
      S3 buckets for the Datadog CloudTrail integration. Separate multiple buckets with commas,
      e.g., "bucket1,bucket2". Permissions will be automatically added to the Datadog integration IAM role.
      https://docs.datadoghq.com/integrations/amazon_cloudtrail/
    Type: String
    Default: ''
  LogArchives:
    Description: >-
      S3 paths to store log archives for log rehydration. Separate multiple paths with comma,
      e.g., "my-bucket,my-bucket-with-path/path".
    Type: String
    Default: ''
  CloudSecurityPostureManagementPermissions:
    Type: String
    Default: false
    AllowedValues:
      - true
      - false
    Description: >-
      Set this value to "true" to add permissions for Datadog's Cloud Security Posture Management product
      to monitor your AWS cloud resource configurations.
      You need this set to "true" to use Cloud Security Posture Management. You will also need "BasePermissions" set to "Full".
  DdAWSAccountId:
    Description: >-
      Datadog AWS account ID allowed to assume the integration IAM role. DO NOT CHANGE!
    Type: String
    Default: "464622532012"
  CloudFormationTypeActivationRole:
    Description: >-
      AWS IAM Role for the role used with the custom Datadog::AWS::Integration resource
    Type: String
  TypeActivationLoggingRole:
    Description: >-
      AWS IAM Role for the role to be used for writing logs for the custom resource
    Type: String
  LambdaExecutionRoleTypeConfig:
    Description: >-
      AWS IAM Role used for executing the type configuration lambda
    Type: String
  LambdaExecutionRoleAPICall:
    Description: >-
      AWS IAM Role used for the stack that creates the API call to Datadog
    Type: String
Conditions:
  GrantFullPermissions:
    Fn::Equals:
      - Ref: ObservabilityPermissions
      - Standard Permissions
  ShouldInstallCSPMPolicy:
    Fn::Equals:
      - Ref: CloudSecurityPostureManagementPermissions
      - true
Resources:
  AWSIntegrationTypeActivation:
    Type: "AWS::CloudFormation::TypeActivation"
    Properties:
      PublicTypeArn:
        !Sub "arn:${AWS::Partition}:cloudformation:${AWS::Region}::type/resource/7171b96e5d207b947eb72ca9ce05247c246de623/Datadog-Integrations-AWS"
      ExecutionRoleArn: !Ref CloudFormationTypeActivationRole
      TypeNameAlias: "Datadog::Integrations::AWSQuickstart"
      LoggingConfig:
        LogGroupName: "AWSIntegrationResource"
        LogRoleArn: !Ref TypeActivationLoggingRole
  ResourceTypeConfiguration:
    Type: "Custom::ResourceTypeConfiguration"
    Properties:
      ServiceToken: !GetAtt TypeConfigurationFunction.Arn
      TypeARN: !Ref AWSIntegrationTypeActivation
      APIKey: !Ref ApiKey
      APPKey: !Ref AppKey
      ApiURL: !Sub ["https://api.${ApiUrl}", {ApiUrl: !Ref ApiUrl}]
  TypeConfigurationFunction:
    Type: "AWS::Lambda::Function"
    Properties:
      Description: "A function to set the type configuration of the Datadog AWS Integration Resource."
      Handler: "index.handler"
      Role: !Ref LambdaExecutionRoleTypeConfig
      Runtime: "python3.8"
      Timeout: 30
      Code:
        ZipFile: |
          import logging
          import boto3
          import json

          import json
          import logging
          import signal
          from urllib.request import build_opener, HTTPHandler, Request
          from urllib.parse import urlencode

          LOGGER = logging.getLogger()
          LOGGER.setLevel(logging.INFO)


          def handler(event, context):
          	'''Handle Lambda event from AWS'''
          	try:
          		LOGGER.info('REQUEST RECEIVED:\n %s', event)
          		LOGGER.info('REQUEST RECEIVED:\n %s', context)
          		if event['RequestType'] == 'Create':
          			LOGGER.info('Received Create request.')
          			resource_type_arn = event['ResourceProperties']['TypeARN']
          			api_key = event['ResourceProperties']['APIKey']
          			app_key = event['ResourceProperties']['APPKey']
          			api_url = event['ResourceProperties'].get('ApiURL')
          			region = context.invoked_function_arn.split(":")[3]

          			credentials_dict = {
          				"DatadogCredentials": {
          					"ApiKey": api_key,
          					"ApplicationKey": app_key,
          				}
          			}
          			if api_url is not None:
          				credentials_dict["DatadogCredentials"]["ApiURL"] = api_url

          			client = boto3.client("cloudformation", region_name=region)
          			client.set_type_configuration(
          				TypeArn=resource_type_arn,
          				Configuration=json.dumps(credentials_dict)
          			)

          			send_response(event, context, "SUCCESS",
          						  {"Message": "Type Configuration set correctly."})
          		elif event['RequestType'] == 'Update':
          			LOGGER.info('Received Update request.')
          			send_response(event, context, "SUCCESS",
          						  {"Message": "Update not supported, no operation performed."})
          		elif event['RequestType'] == 'Delete':
          			LOGGER.info('Received Delete request.')
          			send_response(event, context, "SUCCESS",
          						  {"Message": "Delete not supported, no operation performed."})
          		else:
          			LOGGER.info('Failed - received unexpected request.')
          			send_response(event, context, "FAILED",
          						  {"Message": "Unexpected event received from CloudFormation"})
          	except Exception as e: #pylint: disable=W0702
          		LOGGER.info('Failed - exception thrown during processing.')
          		send_response(event, context, "FAILED", {
          			"Message": "Exception during processing: {}".format(e)})


          def send_response(event, context, response_status, response_data):
          	'''Send a resource manipulation status response to CloudFormation'''
          	response_body = json.dumps({
          		"Status": response_status,
          		"Reason": "See the details in CloudWatch Log Stream: " + context.log_stream_name,
          		"PhysicalResourceId": context.log_stream_name,
          		"StackId": event['StackId'],
          		"RequestId": event['RequestId'],
          		"LogicalResourceId": event['LogicalResourceId'],
          		"Data": response_data
          	})
          	formatted_response = response_body.encode("utf-8")

          	LOGGER.info('ResponseURL: %s', event['ResponseURL'])
          	LOGGER.info('ResponseBody: %s', response_body)

          	opener = build_opener(HTTPHandler)
          	request = Request(event['ResponseURL'], data=formatted_response)
          	request.add_header('Content-Type', 'application/json; charset=utf-8')
          	request.add_header('Content-Length', len(formatted_response))
          	request.get_method = lambda: 'PUT'
          	response = opener.open(request)
          	LOGGER.info("Status code: %s", response.getcode())
          	LOGGER.info("Status message: %s", response.msg)


          def timeout_handler(_signal, _frame):
          	'''Handle SIGALRM'''
          	raise Exception('Time exceeded')


          signal.signal(signal.SIGALRM, timeout_handler)
  DatadogAPICallResource:
    Type: "Custom::DatadogAPICallFunction"
    DependsOn:
      - ResourceTypeConfiguration
      - AWSIntegrationTypeActivation
    Properties:
      ServiceToken: !GetAtt DatadogAPICallFunction.Arn
      Region: !Ref AWS::Region
      RoleName: !Ref IAMRoleName
      HostTags: !Join [ ",", !Ref HostTags ]
  DatadogAPICallFunction:
    Type: "AWS::Lambda::Function"
    Properties:
      Description: "A function to set the type configuration of the Datadog AWS Integration Resource."
      Handler: "index.handler"
      Role: !Ref LambdaExecutionRoleAPICall
      Runtime: "python3.8"
      Timeout: 60
      Code:
        ZipFile: |
          import boto3
          from botocore.exceptions import ClientError

          import json
          import logging
          import signal
          from time import sleep
          from urllib.request import build_opener, HTTPHandler, Request

          LOGGER = logging.getLogger()
          LOGGER.setLevel(logging.INFO)

          TEMPLATE_BODY = """
          AWSTemplateFormatVersion: 2010-09-09
          Description: Datadog AWS Integration API Call
          Parameters:
            RoleName:
              Description: >-
                The name of the IAM role created for Datadog's use.
              Type: String
            HostTags:
              Type: CommaDelimitedList
              Default: ""
              Description: >-
                A comma seperated list of tags to add to hosts and metrics
          Resources:
            DatadogAWSAccountIntegration:
              Type: Datadog::Integrations::AWSQuickstart
              Properties:
                AccountID: !Ref AWS::AccountId
                RoleName: !Ref RoleName
                HostTags: !Ref HostTags
          """

          BACKOFFS = [5, 10, 15, 20]


          def handler(event, context):
              '''Handle Lambda event from AWS'''
              try:
                  LOGGER.info('REQUEST RECEIVED:\n %s', event)
                  LOGGER.info('REQUEST RECEIVED:\n %s', context)
                  if event['RequestType'] == 'Create':
                      LOGGER.info('Received Create request.')
                      region = event['ResourceProperties']['Region']
                      role_name = event['ResourceProperties']['RoleName']
                      host_tags = event['ResourceProperties']['HostTags']

                      client = boto3.client("cloudformation", region_name=region)
                      client.create_stack(
                          StackName="DatadogAWSIntegrationAPICall",
                          TemplateBody=TEMPLATE_BODY,
                          Parameters=[
                              {"ParameterKey": "RoleName", "ParameterValue": role_name},
                              {"ParameterKey": "HostTags", "ParameterValue": host_tags},
                          ]
                      )

                      # Wait for cloudformation template to finish running
                      for backoff in BACKOFFS:
                          sleep(backoff)

                          secretsmanager_client = boto3.client("secretsmanager", region_name=region)
                          try:
                              secret_json = secretsmanager_client.get_secret_value(
                                  SecretId="DatadogIntegrationExternalID"
                              )["SecretString"]
                          except ClientError as e:
                              if e.response['Error']['Code'] == 'ResourceNotFoundException':
                                  continue
                              raise e
                      send_response(event, context, "SUCCESS",
                                    {"Message": "Datadog AWS Integration made successfully.",
                                     "ExternalID": json.loads(secret_json)["external_id"]})
                  elif event['RequestType'] == 'Update':
                      LOGGER.info('Received Update request.')
                      send_response(event, context, "SUCCESS",
                                    {"Message": "Update not supported, no operation performed."})
                  elif event['RequestType'] == 'Delete':
                      LOGGER.info('Received Delete request.')
                      region = event['ResourceProperties']['Region']

                      client = boto3.client("cloudformation", region_name=region)
                      client.delete_stack(
                          StackName="DatadogAWSIntegrationAPICall"
                      )

                      send_response(event, context, "SUCCESS",
                                    {"Message": "Datadog AWS Integration deleted successfully."})
                  else:
                      LOGGER.info('Failed - received unexpected request.')
                      send_response(event, context, "FAILED",
                                    {"Message": "Unexpected event received from CloudFormation"})
              except Exception as e:  # pylint: disable=W0702
                  LOGGER.info('Failed - exception thrown during processing.')
                  send_response(event, context, "FAILED", {
                      "Message": "Exception during processing: {}".format(e)})


          def send_response(event, context, response_status, response_data):
              '''Send a resource manipulation status response to CloudFormation'''
              response_body = json.dumps({
                  "Status": response_status,
                  "Reason": "See the details in CloudWatch Log Stream: " + context.log_stream_name,
                  "PhysicalResourceId": context.log_stream_name,
                  "StackId": event['StackId'],
                  "RequestId": event['RequestId'],
                  "LogicalResourceId": event['LogicalResourceId'],
                  "Data": response_data
              })
              formatted_response = response_body.encode("utf-8")

              LOGGER.info('ResponseURL: %s', event['ResponseURL'])
              LOGGER.info('ResponseBody: %s', response_body)

              opener = build_opener(HTTPHandler)
              request = Request(event['ResponseURL'], data=formatted_response)
              request.add_header('Content-Type', 'application/json; charset=utf-8')
              request.add_header('Content-Length', len(formatted_response))
              request.get_method = lambda: 'PUT'
              response = opener.open(request)
              LOGGER.info("Status code: %s", response.getcode())
              LOGGER.info("Status message: %s", response.msg)


          def timeout_handler(_signal, _frame):
              '''Handle SIGALRM'''
              raise Exception('Time exceeded')


          signal.signal(signal.SIGALRM, timeout_handler)
  DatadogIntegrationRole:
    Type: 'AWS::IAM::Role'
    Metadata:
      cfn-lint:
        config:
          # cfn-lint does not yet support "Fn::Transform"
          # This policy needs broad read permissions to allow Datadog to collect metrics and metadata
          ignore_checks:
            - E3002
            - E3003
            - EIAMPolicyActionWildcard
            - EIAMPolicyWildcardResource
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              AWS: !Sub "arn:${AWS::Partition}:iam::${DdAWSAccountId}:root"
            Action:
              - 'sts:AssumeRole'
            Condition:
              StringEquals:
                'sts:ExternalId': !GetAtt DatadogAPICallResource.ExternalID
      Path: /
      RoleName: !Ref IAMRoleName
      ManagedPolicyArns: !If [ ShouldInstallCSPMPolicy, [ !Sub "arn:${AWS::Partition}:iam::aws:policy/SecurityAudit" ], !Ref AWS::NoValue ]
      Policies:
        - PolicyName: DatadogAWSIntegrationPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - !If
                - GrantFullPermissions
                - Effect: Allow
                  Resource: !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:role/${IAMRoleName}'
                  Action:
                    - 'iam:List*'
                    - 'iam:Get*'
                - !Ref AWS::NoValue
              - !If
                - GrantFullPermissions
                - Effect: Allow
                  Resource: '*'
                  Action:
                    - 'apigateway:GET'
                    - 'autoscaling:Describe*'
                    - 'budgets:ViewBudget'
                    - 'cloudfront:GetDistributionConfig'
                    - 'cloudfront:ListDistributions'
                    - 'cloudtrail:DescribeTrails'
                    - 'cloudtrail:GetTrailStatus'
                    - 'cloudtrail:LookupEvents'
                    - 'cloudwatch:Describe*'
                    - 'cloudwatch:Get*'
                    - 'cloudwatch:List*'
                    - 'codedeploy:List*'
                    - 'codedeploy:BatchGet*'
                    - 'directconnect:Describe*'
                    - 'dynamodb:List*'
                    - 'dynamodb:Describe*'
                    - 'ec2:Describe*'
                    - 'ecs:Describe*'
                    - 'ecs:List*'
                    - 'elasticache:Describe*'
                    - 'elasticache:List*'
                    - 'elasticfilesystem:DescribeAccessPoints'
                    - 'elasticfilesystem:DescribeFileSystems'
                    - 'elasticfilesystem:DescribeTags'
                    - 'elasticloadbalancing:Describe*'
                    - 'elasticmapreduce:List*'
                    - 'elasticmapreduce:Describe*'
                    - 'es:ListTags'
                    - 'es:ListDomainNames'
                    - 'es:DescribeElasticsearchDomains'
                    - 'fsx:DescribeFileSystems'
                    - 'fsx:ListTagsForResource'
                    - 'health:DescribeEvents'
                    - 'health:DescribeEventDetails'
                    - 'health:DescribeAffectedEntities'
                    - 'kinesis:List*'
                    - 'kinesis:Describe*'
                    - 'lambda:GetPolicy'
                    - 'lambda:List*'
                    - 'logs:TestMetricFilter'
                    - 'logs:PutSubscriptionFilter'
                    - 'logs:DeleteSubscriptionFilter'
                    - 'logs:DescribeSubscriptionFilters'
                    - 'organizations:DescribeOrganization'
                    - 'rds:Describe*'
                    - 'rds:List*'
                    - 'redshift:DescribeClusters'
                    - 'redshift:DescribeLoggingStatus'
                    - 'route53:List*'
                    - 's3:GetBucketLogging'
                    - 's3:GetBucketLocation'
                    - 's3:GetBucketNotification'
                    - 's3:GetBucketTagging'
                    - 's3:ListAllMyBuckets'
                    - 's3:PutBucketNotification'
                    - 'ses:Get*'
                    - 'sns:List*'
                    - 'sns:Publish'
                    - 'sqs:ListQueues'
                    - 'states:ListStateMachines'
                    - 'states:DescribeStateMachine'
                    - 'support:*'
                    - 'tag:GetResources'
                    - 'tag:GetTagKeys'
                    - 'tag:GetTagValues'
                    - 'xray:BatchGetTraces'
                    - 'xray:GetTraceSummaries'
                - Effect: Allow
                  Resource: '*'
                  Action:
                    - 'cloudwatch:Get*'
                    - 'cloudwatch:List*'
                    - 'ec2:Describe*'
                    - 'support:*'
                    - 'tag:GetResources'
                    - 'tag:GetTagKeys'
                    - 'tag:GetTagValues'
        - Fn::Transform:
            - Name: 'DatadogPolicy'
              Parameters:
                PolicyType: LogArchive
                LogArchives: !Ref LogArchives
                Partition: !Ref AWS::Partition
        - Fn::Transform:
            - Name: 'DatadogPolicy'
              Parameters:
                PolicyType: CloudTrail
                CloudTrails: !Ref CloudTrails
                Partition: !Ref AWS::Partition
