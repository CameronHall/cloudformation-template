AWSTemplateFormatVersion: 2010-09-09
Description: Resource Type Configuration
Parameters:
  SecretName:
    Description: >-
      An AWS SecretsManager ARN of a secret containing your API Key, APP Key, and Datadog Site.
    Type: String
    Default: ""
  APIKey:
    Description: >-
      Your Datadog API Key
    Type: String
    Default: ""
  APPKey:
    Description: >-
      Your Datadog APP Key
    Type: String
    Default: ""
  DdSite:
    Type: String
    Default: datadoghq.com
    Description: Define your Datadog Site to send data to.
    AllowedValues:
      - datadoghq.com
      - datadoghq.eu
      - us3.datadoghq.com
      - us5.datadoghq.com
      - ddog-gov.com
    ConstraintDescription: DdSite is required
  IAMRoleName:
    Description: >-
      The name of the IAM Role used for the Datadog AWS Integration
    Type: String
    Default: DatadogIntegrationRole
  HostTags:
    Type: CommaDelimitedList
    Default: ""
    Description: >-
      A comma seperated list of tags to add to hosts and metrics
  CloudFormationTypeActivationRole:
    Description: >-
      The name of the IAM Role used for the Datadog AWS Integration
    Type: String
  TypeActivationLoggingRole:
    Description: >-
      The name of the IAM Role used for the Datadog AWS Integration
    Type: String
  LambdaExecutionRoleTypeConfig:
    Description: >-
      The name of the IAM Role used for the Datadog AWS Integration
    Type: String
  LambdaExecutionRoleAPICall:
    Description: >-
      The name of the IAM Role used for the Datadog AWS Integration
    Type: String
  ObservabilityPermissions:
    Description: >-
      Customize the observability permissions for the Datadog IAM role.
      Select "Limited Permissions" to only grant Datadog permissions to monitor a limited set of metrics and metadata
      (not recommended).
    Type: String
    Default: Standard Permissions
    AllowedValues:
      - Standard Permissions
      - Limited Permissions
  LogArchives:
    Description: >-
      S3 paths to store log archives for log rehydration. Separate multiple paths with comma,
      e.g., "my-bucket,my-bucket-with-path/path".
    Type: String
    Default: ''
  CloudSecurityPostureManagementPermissions:
    Type: String
    Default: false
    AllowedValues:
      - true
      - false
    Description: >-
      Set this value to "true" to add permissions for Datadog's Cloud Security Posture Management product
      to monitor your AWS cloud resource configurations.
      You need this set to "true" to use Cloud Security Posture Management. You will also need "BasePermissions" set to "Full".
  DdAWSAccountId:
    Description: >-
      Datadog AWS account ID allowed to assume the integration IAM role. DO NOT CHANGE!
    Type: String
    Default: "464622532012"
  CloudTrails:
    Description: >-
      S3 buckets for the Datadog CloudTrail integration. Separate multiple buckets with commas,
      e.g., "bucket1,bucket2". Permissions will be automatically added to the Datadog integration IAM role.
      https://docs.datadoghq.com/integrations/amazon_cloudtrail/
    Type: String
    Default: ''
Conditions:
  GrantFullPermissions:
    Fn::Equals:
      - Ref: ObservabilityPermissions
      - Standard Permissions
  ShouldInstallCSPMPolicy:
    Fn::Equals:
      - Ref: CloudSecurityPostureManagementPermissions
      - true
Resources:
  AWSIntegrationTypeActivation:
    Type: "AWS::CloudFormation::TypeActivation"
    Properties:
      PublicTypeArn:
        !Join
          - ''
          -
            - "arn:aws:cloudformation:"
            - !Ref AWS::Region
            - "::type/resource/7171b96e5d207b947eb72ca9ce05247c246de623/Datadog-Integrations-AWS"
      ExecutionRoleArn: !Ref CloudFormationTypeActivationRole
      TypeNameAlias: "Datadog::Integrations::AWSQuickstart"
      LoggingConfig:
        LogGroupName: "AWSIntegrationResource"
        LogRoleArn: !Ref TypeActivationLoggingRole
  ResourceTypeConfiguration:
    Type: "Custom::ResourceTypeConfiguration"
    Properties:
      ServiceToken: !GetAtt TypeConfigurationFunction.Arn
      TypeARN: !Ref AWSIntegrationTypeActivation
      SecretName: !Ref SecretName
      APIKey: !Ref APIKey
      APPKey: !Ref APPKey
      ApiURL: !Sub ["https://api.${DdSite}", {DdSite: !Ref DdSite}]
  TypeConfigurationFunction:
    Type: "AWS::Lambda::Function"
    Properties:
      Description: "A function to set the type configuration of the Datadog AWS Integration Resource."
      Handler: "index.handler"
      Role: !Ref LambdaExecutionRoleTypeConfig
      Runtime: "python3.8"
      Timeout: 30
      Code:
        ZipFile: |
          import boto3

          import json
          import logging
          import signal
          from urllib.request import build_opener, HTTPHandler, Request

          LOGGER = logging.getLogger()
          LOGGER.setLevel(logging.INFO)


          def handler(event, context):
          	'''Handle Lambda event from AWS'''
          	try:
          		LOGGER.info('REQUEST RECEIVED:\n %s', event)
          		LOGGER.info('REQUEST RECEIVED:\n %s', context)
          		if event['RequestType'] == 'Create':
          			LOGGER.info('Received Create request.')
          			resource_type_arn = event['ResourceProperties']['TypeARN']
          			api_key = event['ResourceProperties']['APIKey']
          			app_key = event['ResourceProperties']['APPKey']
          			api_url = event['ResourceProperties'].get('ApiURL')

          			credentials_dict = {
          				"DatadogCredentials":{
          					"ApiKey": api_key,
          					"ApplicationKey": app_key,
          				}
          			}
          			if api_url is not None:
          				credentials_dict["DatadogCredentials"]["ApiURL"] = api_url

          			region = context.invoked_function_arn.split(":")[3]
          			client = boto3.client("cloudformation", region_name=region)
          			client.set_type_configuration(
          				TypeArn=resource_type_arn,
          				Configuration=json.dumps(credentials_dict)
          			)

          			send_response(event, context, "SUCCESS",
          						  {"Message": "Type Configuration set correctly."})
          		elif event['RequestType'] == 'Update':
          			LOGGER.info('Received Update request.')
          			send_response(event, context, "SUCCESS",
          						  {"Message": "Update not supported, no operation performed."})
          		elif event['RequestType'] == 'Delete':
          			LOGGER.info('Received Delete request.')
          			send_response(event, context, "SUCCESS",
          						  {"Message": "Delete not supported, no operation performed."})
          		else:
          			LOGGER.info('Failed - received unexpected request.')
          			send_response(event, context, "FAILED",
          						  {"Message": "Unexpected event received from CloudFormation"})
          	except Exception as e: #pylint: disable=W0702
          		LOGGER.info('Failed - exception thrown during processing.')
          		send_response(event, context, "FAILED", {
          			"Message": "Exception during processing: {}".format(e)})


          def send_response(event, context, response_status, response_data):
          	'''Send a resource manipulation status response to CloudFormation'''
          	response_body = json.dumps({
          		"Status": response_status,
          		"Reason": "See the details in CloudWatch Log Stream: " + context.log_stream_name,
          		"PhysicalResourceId": context.log_stream_name,
          		"StackId": event['StackId'],
          		"RequestId": event['RequestId'],
          		"LogicalResourceId": event['LogicalResourceId'],
          		"Data": response_data
          	})
          	formatted_response = response_body.encode("utf-8")

          	LOGGER.info('ResponseURL: %s', event['ResponseURL'])
          	LOGGER.info('ResponseBody: %s', response_body)

          	opener = build_opener(HTTPHandler)
          	request = Request(event['ResponseURL'], data=formatted_response)
          	request.add_header('Content-Type', 'application/json; charset=utf-8')
          	request.add_header('Content-Length', len(formatted_response))
          	request.get_method = lambda: 'PUT'
          	response = opener.open(request)
          	LOGGER.info("Status code: %s", response.getcode())
          	LOGGER.info("Status message: %s", response.msg)


          def timeout_handler(_signal, _frame):
          	'''Handle SIGALRM'''
          	raise Exception('Time exceeded')


          signal.signal(signal.SIGALRM, timeout_handler)
  DatadogAPICallResource:
    Type: "Custom::DatadogAPICallFunction"
    DependsOn:
      - ResourceTypeConfiguration
      - AWSIntegrationTypeActivation
    Properties:
      ServiceToken: !GetAtt DatadogAPICallFunction.Arn
      Region: !Ref AWS::Region
      RoleName: !Ref IAMRoleName
      HostTags: !Join [ ",", !Ref HostTags ]
  DatadogAPICallFunction:
    Type: "AWS::Lambda::Function"
    Properties:
      Description: "A function to set the type configuration of the Datadog AWS Integration Resource."
      Handler: "index.handler"
      Role: !Ref LambdaExecutionRoleAPICall
      Runtime: "python3.8"
      Timeout: 30
      Code:
        ZipFile: |
          import boto3

          import json
          import logging
          import signal
          from urllib.request import build_opener, HTTPHandler, Request

          LOGGER = logging.getLogger()
          LOGGER.setLevel(logging.INFO)

          TEMPLATE_BODY = """
          AWSTemplateFormatVersion: 2010-09-09
          Description: Datadog AWS Integration API Call
          Parameters:
            RoleName:
              Description: >-
                The name of the IAM role created for Datadog's use.
              Type: String
            HostTags:
              Type: CommaDelimitedList
              Default: ""
              Description: >-
                A comma seperated list of tags to add to hosts and metrics
          Resources:
            DatadogAWSAccountIntegration:
              Type: Datadog::Integrations::AWSQuickstart
              Properties:
                AccountID: !Ref AWS::AccountId
                RoleName: !Ref RoleName
                HostTags: !Ref HostTags
          """


          def handler(event, context):
              '''Handle Lambda event from AWS'''
              try:
                  LOGGER.info('REQUEST RECEIVED:\n %s', event)
                  LOGGER.info('REQUEST RECEIVED:\n %s', context)
                  if event['RequestType'] == 'Create':
                      LOGGER.info('Received Create request.')
                      region = event['ResourceProperties']['Region']
                      role_name = event['ResourceProperties']['RoleName']
                      host_tags = event['ResourceProperties']['HostTags']

                      client = boto3.client("cloudformation", region_name=region)
                      client.create_stack(
                          StackName="DatadogAWSIntegrationAPICall",
                          TemplateBody=TEMPLATE_BODY,
                          Parameters=[
                              {"ParameterKey": "RoleName", "ParameterValue": role_name},
                              {"ParameterKey": "HostTags", "ParameterValue": host_tags},
                          ]
                      )
                      secretsmanager_client = boto3.client("secretsmanager", region_name=region)
                      secret_json = secretsmanager_client.get_secret_value(
                          SecretId="DatadogIntegrationExternalID"
                      )["SecretString"]

                      send_response(event, context, "SUCCESS",
                                    {"Message": "Type Configuration set correctly.",
                                     "ExternalID": json.loads(secret_json)["external_id"]})
                  elif event['RequestType'] == 'Update':
                      LOGGER.info('Received Update request.')
                      send_response(event, context, "SUCCESS",
                                    {"Message": "Update not supported, no operation performed."})
                  elif event['RequestType'] == 'Delete':
                      LOGGER.info('Received Delete request.')
                      region = event['ResourceProperties']['Region']

                      client = boto3.client("cloudformation", region_name=region)
                      client.delete_stack(
                          StackName="DatadogAWSIntegrationAPICall"
                      )

                      send_response(event, context, "SUCCESS",
                                    {"Message": "Delete not supported, no operation performed."})
                  else:
                      LOGGER.info('Failed - received unexpected request.')
                      send_response(event, context, "FAILED",
                                    {"Message": "Unexpected event received from CloudFormation"})
              except Exception as e:  # pylint: disable=W0702
                  LOGGER.info('Failed - exception thrown during processing.')
                  send_response(event, context, "FAILED", {
                      "Message": "Exception during processing: {}".format(e)})


          def send_response(event, context, response_status, response_data):
              '''Send a resource manipulation status response to CloudFormation'''
              response_body = json.dumps({
                  "Status": response_status,
                  "Reason": "See the details in CloudWatch Log Stream: " + context.log_stream_name,
                  "PhysicalResourceId": context.log_stream_name,
                  "StackId": event['StackId'],
                  "RequestId": event['RequestId'],
                  "LogicalResourceId": event['LogicalResourceId'],
                  "Data": response_data
              })
              formatted_response = response_body.encode("utf-8")

              LOGGER.info('ResponseURL: %s', event['ResponseURL'])
              LOGGER.info('ResponseBody: %s', response_body)

              opener = build_opener(HTTPHandler)
              request = Request(event['ResponseURL'], data=formatted_response)
              request.add_header('Content-Type', 'application/json; charset=utf-8')
              request.add_header('Content-Length', len(formatted_response))
              request.get_method = lambda: 'PUT'
              response = opener.open(request)
              LOGGER.info("Status code: %s", response.getcode())
              LOGGER.info("Status message: %s", response.msg)


          def timeout_handler(_signal, _frame):
              '''Handle SIGALRM'''
              raise Exception('Time exceeded')


          signal.signal(signal.SIGALRM, timeout_handler)
  DatadogIntegrationRole:
    Type: 'AWS::IAM::Role'
    Metadata:
      cfn-lint:
        config:
          # cfn-lint does not yet support "Fn::Transform"
          ignore_checks:
            - E3002
            - E3003
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              AWS: !Sub
                - 'arn:aws:iam::${DdAWSAccountId}:root'
                - { DdAWSAccountId: !Ref DdAWSAccountId }
            Action:
              - 'sts:AssumeRole'
            Condition:
              StringEquals:
                'sts:ExternalId': !GetAtt DatadogAPICallResource.ExternalID
      Path: /
      RoleName: !Ref IAMRoleName
      ManagedPolicyArns: !If [ ShouldInstallCSPMPolicy, [ 'arn:aws:iam::aws:policy/SecurityAudit' ], !Ref AWS::NoValue ]
      Policies:
        - PolicyName: DatadogAWSIntegrationPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - !If
                - GrantFullPermissions
                - Effect: Allow
                  Resource: !Sub
                    - 'arn:aws:iam::${account}:role/${role}'
                    - { account: !Ref AWS::AccountId, role: !Ref IAMRoleName }
                  Action:
                    - 'iam:List*'
                    - 'iam:Get*'
                - !Ref AWS::NoValue
              - !If
                - GrantFullPermissions
                - Effect: Allow
                  Resource: '*'
                  Action:
                    - 'apigateway:GET'
                    - 'autoscaling:Describe*'
                    - 'budgets:ViewBudget'
                    - 'cloudfront:GetDistributionConfig'
                    - 'cloudfront:ListDistributions'
                    - 'cloudtrail:DescribeTrails'
                    - 'cloudtrail:GetTrailStatus'
                    - 'cloudtrail:LookupEvents'
                    - 'cloudwatch:Describe*'
                    - 'cloudwatch:Get*'
                    - 'cloudwatch:List*'
                    - 'codedeploy:List*'
                    - 'codedeploy:BatchGet*'
                    - 'directconnect:Describe*'
                    - 'dynamodb:List*'
                    - 'dynamodb:Describe*'
                    - 'ec2:Describe*'
                    - 'ecs:Describe*'
                    - 'ecs:List*'
                    - 'elasticache:Describe*'
                    - 'elasticache:List*'
                    - 'elasticfilesystem:DescribeAccessPoints'
                    - 'elasticfilesystem:DescribeFileSystems'
                    - 'elasticfilesystem:DescribeTags'
                    - 'elasticloadbalancing:Describe*'
                    - 'elasticmapreduce:List*'
                    - 'elasticmapreduce:Describe*'
                    - 'es:ListTags'
                    - 'es:ListDomainNames'
                    - 'es:DescribeElasticsearchDomains'
                    - 'fsx:DescribeFileSystems'
                    - 'fsx:ListTagsForResource'
                    - 'health:DescribeEvents'
                    - 'health:DescribeEventDetails'
                    - 'health:DescribeAffectedEntities'
                    - 'kinesis:List*'
                    - 'kinesis:Describe*'
                    - 'lambda:GetPolicy'
                    - 'lambda:List*'
                    - 'logs:TestMetricFilter'
                    - 'logs:PutSubscriptionFilter'
                    - 'logs:DeleteSubscriptionFilter'
                    - 'logs:DescribeSubscriptionFilters'
                    - 'organizations:DescribeOrganization'
                    - 'rds:Describe*'
                    - 'rds:List*'
                    - 'redshift:DescribeClusters'
                    - 'redshift:DescribeLoggingStatus'
                    - 'route53:List*'
                    - 's3:GetBucketLogging'
                    - 's3:GetBucketLocation'
                    - 's3:GetBucketNotification'
                    - 's3:GetBucketTagging'
                    - 's3:ListAllMyBuckets'
                    - 's3:PutBucketNotification'
                    - 'ses:Get*'
                    - 'sns:List*'
                    - 'sns:Publish'
                    - 'sqs:ListQueues'
                    - 'states:ListStateMachines'
                    - 'states:DescribeStateMachine'
                    - 'support:*'
                    - 'tag:GetResources'
                    - 'tag:GetTagKeys'
                    - 'tag:GetTagValues'
                    - 'xray:BatchGetTraces'
                    - 'xray:GetTraceSummaries'
                - Effect: Allow
                  Resource: '*'
                  Action:
                    - 'cloudwatch:Get*'
                    - 'cloudwatch:List*'
                    - 'ec2:Describe*'
                    - 'support:*'
                    - 'tag:GetResources'
                    - 'tag:GetTagKeys'
                    - 'tag:GetTagValues'
        - Fn::Transform:
            - Name: 'DatadogPolicy'
              Parameters:
                PolicyType: LogArchive
                LogArchives: !Ref LogArchives
        - Fn::Transform:
            - Name: 'DatadogPolicy'
              Parameters:
                PolicyType: CloudTrail
                CloudTrails: !Ref CloudTrails
